import { ContactSupportDto, GetNotificationsQueryParamsDto, GetUsersQueryParamsDto } from '@lib/dtos';
import { type UpdateProfileRequestDto } from '@lib/dtos/profile';
import { BlockUserReason, IUserAccountTransaction, TransactionActionTypes, UserInterestedGenderEnum, UserRoleEnum, UserSelfGenderEnum, UserStatusEnum } from '@lib/types';
import { ConfigService } from '@nestjs/config';
import { EntityManager, Repository } from 'typeorm';
import { AuthHelper } from '../auth/auth.helper';
import { MailService } from '../mail/mail.service';
import { GlobalResponseDto } from './../../../libs/dtos/src/common/index';
import { Favorite } from './entities/customer.favourite.entity';
import { CustomerProfileData } from './entities/customer.profiledata.entity';
import { UserAccountTransaction } from './entities/user.account.transaction.entity';
import { Address } from './entities/user.address.entity';
import { Block } from './entities/user.block.entity';
import { User } from './entities/user.entity';
import { Photo } from './entities/user.photos.entity';
import { VisitProfile } from './entities/visit.profile.entity';
import { CloudinaryConfigService } from '@config/cloudinary.config';
import { ContactSupport } from './entities/contactSupport.entity';
import { Notifications } from './entities/notifications.entity';
export declare class UserService {
    private readonly userRepository;
    private readonly entity;
    private readonly config;
    private readonly helper;
    private readonly mailService;
    private cloudinary;
    constructor(userRepository: Repository<User>, entity: EntityManager, config: ConfigService, helper: AuthHelper, mailService: MailService, cloudinary: CloudinaryConfigService);
    createAdmin(): Promise<void>;
    createAdminFake(): Promise<void>;
    updateInfoById(id: string, body: UpdateProfileRequestDto, files: any): Promise<any>;
    getCurrentCoinsFromDB(user: User | any): Promise<number>;
    getActionTypeCostFromDB(actionType: TransactionActionTypes | string): Promise<number>;
    mockData(): Promise<void>;
    addToVisit(visited: string, token: string, fakeId?: string): Promise<VisitProfile>;
    getVisits(token: string): Promise<VisitProfile[]>;
    markFavorite(favoriteId: string, token: string): Promise<void>;
    getFavorites(token: string): Promise<Favorite[]>;
    getRandom(token: string): Promise<User>;
    findAll(token?: string, params?: GetUsersQueryParamsDto, schedule?: boolean): Promise<{
        page: string;
        pageSize: number;
        nextPage: number;
        total: any;
        data: any;
    }>;
    getCustomer(userId: string): Promise<any>;
    getCustomerData(email: string): Promise<User>;
    updateOnlineStatus(userId: string, onlineStatus: boolean): Promise<void>;
    checkOnlineStatus(userId: string): Promise<boolean>;
    savePhoto(file: any, folderName: any): Promise<any>;
    transaction(user: User, currentCoins: number, action: any): Promise<void>;
    getCoordinatesFromAddress(address: string): Promise<[number, number, string]>;
    validateAndSaveAddress(address: string, user: User): Promise<Address>;
    validateAndSaveDOB(table: CustomerProfileData, dob: string): Promise<void>;
    getUsersDistance(user1Id: string, user2Id: string): Promise<number>;
    deg2rad(deg: any): Promise<number>;
    markBlock(userId: string, token: string, reason: BlockUserReason): Promise<void>;
    getBlocked(token: string): Promise<Block[]>;
    removeBlocked(userId: string, token: string): Promise<void>;
    validateAndUpdatePassword(currentPassword: string, newPassword: string, user: User): Promise<void>;
    convertToBase64(image: string | any, user: User): Promise<string>;
    saveMultiplePhotosToDB(photosPaths: any, photos: any, user: User, folder: string): Promise<void>;
    removeUser(token: string): Promise<GlobalResponseDto>;
    removePhoto(id: string, token: string): Promise<any>;
    contactSupport(body: ContactSupportDto): Promise<GlobalResponseDto>;
    addContactRecord(message: string, user?: User): Promise<void>;
    demoUsers(): Promise<void>;
    getCoins(token: string): Promise<number>;
    makeTransaction(token: string, actionType: TransactionActionTypes, receiverId?: string, subAction?: string, bonus?: string): Promise<{
        success: boolean;
    }>;
    processEmojiGiftTransaction(sender: User, receiver: User, action: TransactionActionTypes, subAction: string, entity: EntityManager, tableTransactions: any, tableActionTypes: any): Promise<{
        success: boolean;
    }>;
    addTransactions(action: TransactionActionTypes | string, user: User | any, entity: EntityManager, tableTransactions: any, tableActionTypes: any, currentCoins?: number, bonusCost?: number): Promise<IUserAccountTransaction>;
    markUserAsSeenInProfileVisits(visitorId: string, visitedId: string): Promise<VisitProfile>;
    randomlySetOnline(users: User[]): Promise<(User | {
        online: boolean;
        id: string;
        firstName: string;
        lastName: string;
        userName: string;
        email: string;
        password?: string;
        SocialProvider?: import("@lib/types").SocialProviderEnum;
        status: UserStatusEnum;
        role: UserRoleEnum;
        selfGender: UserSelfGenderEnum;
        interestedGender: UserInterestedGenderEnum;
        disable: boolean;
        createdAt: Date;
        updatedAt: Date;
        profile: CustomerProfileData;
        address: Address;
        transaction: UserAccountTransaction;
        contactSupport: ContactSupport;
        visits: VisitProfile;
        notifications: Notifications;
        blocked: Block;
        favorite: Favorite;
        photos: Photo[];
        payments: import("../payments/entities/payment.entity").Payments;
        fakes: import("./entities/fakeUser.entity").FakeCreator;
        fallOutFakes: import("./entities/user.fallout.entity").FallOutUsers;
        fallOutUsers: import("./entities/user.fallout.entity").FallOutUsers;
        bonus: import("./entities/user.fallout.entity").FallOutUsers;
        usedBonusCodes: import("../auth/entities/userBonusCode.entity").UserBonusCode[];
    })[]>;
    scheduleRandomlySetOnline(): void;
    scheduleRandomVisit(): void;
    getNotifications(token: string, params: GetNotificationsQueryParamsDto): Promise<{
        page: string;
        pageSize: number;
        nextPage: number;
        notifications: any;
        unseenCount: number;
    }>;
    seenNotification(token: string, id: string): Promise<(Notifications | {
        count: number;
    })[]>;
    seenNotifications(token: string): Promise<(Notifications | {
        count: number;
    })[]>;
}
